\chapter{Features Creation}

When we decided which features could be the most representative for our model, we choose to use only static features. We are looking for a framework fast and efficient, that can analyze lots of sample without being resource expensive.

At first, we tried to replicate the work done by Caliskan et al., but we found that most of the tools used depend on software no more maintained. Some of those tools do not work as expected, and others were slow in processing files. To simplify as much as possible the process of analyzing executables, we decided to use only Ghidra as software for extracting features.\\


Ghidra comes with a headless analyzer, which analyzes and runs scripts on the given sample. The headless version can run in any server, even without a desktop environment. So we built up a virtual machine in the Sapienza network and installed Ghidra there.  Unfortunately, Ghidra's documentation is not exhaustive since it was released less than a year ago. The hardest part was understanding Ghidra's APIs and how to exploit them for our purpose. The already made scripts were useful for our task because they contain many approaches for extracting data. \\


\section{Disassemble features}

The extraction of disassembled code was an easy and fast task. The documentation provides all the information on how to correctly use the disassembler. We wrote a script that extracts the disassembled code for each function and stores it into a .dis file. The script creates a folder for each sample and stores inside the disassembled code.

From the disassembled code, we extracted 5 kinds of various features:
\begin{itemize}
	\item{Entire line unigrams}
	\item{Disassemble unigrams}
	\item{Disassemble bigrams}
	\item{Instruction only unigrams}
	\item{Instruction only bigrams}
\end{itemize}

First of all, we stripped out all the hexadecimal and numbers, replacing the regex '\d+' with the word 'number', and '0[xX][0-9a-fA-F]+' with the word hexadecimal. Stripping the numbers and hexadecimal reduced the possibility of overfitting because some numbers may be unique, and that would create a useless feature.

Furthermore, we create a .csv file for each sample, containing all the features calculated, the md5, used as an identifier of the executable, and the apt name. Then all the files are merged into a big .h5 with all the samples. 
In the first approach, we stored all the features into a .csv file, but the more features we extract, the more significant were the dimensionality of our dataset. When it comes to reading into python, pandas was very slow in both reading and processing the files.
A valid alternative to pandas is Dask, a flexible parallel computing library for analytics, that integrates with pandas,  numpy, and scikit. However, the dask-ml package lacks some functionalities for the cross-validation and random forest model. Furthermore, It was still slow in reading bigger files, so we decided to find another solution to speed up the process.
In the end, we decided to store our dataset into a Hierarchical Data Format (HDF5) designed to store and organize large amounts of data. This format comes with a cost, the files are much bigger, but we drastically improved the speed of reading and processing the dataset.

\subsection{Entire line unigram}
The first block of features is the whole line unigram, we split the disassembled code of each function on the new-line character and then count all the occurrences of different line instructions. We stripped out all the commas because, in the beginning, we saved the dataset to .csv with comma as a separator. For example, the features of the following disassembled function would be:

\begin{table}[!htb]
\begin{minipage}{.5\linewidth}
	\centering
	
	\caption{Code for function f}
	\label{tab:function_f}
	
	\medskip
	
	\begin{tabular}{ l } 
		\toprule
		push ebx \\
		mov eax, 1\\
		cmp ebx, eax\\
		jle 0xDEADBEEF\\
		add eax, 1\\
		cmp ebx, eax\\
		jle 0xBACADDAC\\
		mov eax, 0x400231BC\\
		call eax\\
		ret\\
	
		
		\bottomrule
	\end{tabular}
\end{minipage}\hfill
\begin{minipage}{.5\linewidth}
	\centering
	
	\caption{Entire line unigrams}
	\label{tab:line_unigrams}
	
	\medskip
	
	\begin{tabular}{  lr } 
		\toprule
		\makecell{ Feature }  &  Value \\   
		
		\midrule push ebx       & 1         \\
		mov eax,number & 1                  \\ 
		cmp ebx,eax    & 2                  \\ 
		add ebx, number     & 2                  \\ 
		jle hex        & 2                  \\
		mov eax, hexadecimal & 1\\ 
		call eax       & 1                  \\
		ret & 1\\ 
		apt            & PatchWork          \\ 
		md5            & 1234dc...eb121 \\ 
		\bottomrule
	\end{tabular}
\end{minipage}
\end{table}


\subsection{Disassemble unigrams and bigrams}
For this block of features, we split the entire line in instruction, eventual registers, or numbers. We first divided on the first space, and then if the second half of the string still contains data, we split for all the commas to get the single registers/number. the line "mov eax, 0x12" would be split in the following array: ["mov", "eax", "hexadecimal"] . As before, we counted the occurrences of every word in the file. 

For the unigram files, we only considered as a feature every word we would obtain after splitting the string. For the bigram files, instead, we considered as a feature the pair of words in the file. 

Furthermore, we added a start token ("<s>")at the beginning of the function file, and an end token ("</s>") at the end of the file. We concatenate the first and second element of the bigram with the the string "=>" The features generated from the same disassembled code would be the following: 

\begin{table}[!htb]
	\begin{minipage}{.5\linewidth}
		\centering
		
		\caption{Disassemble unigrams}
		\label{tab:dis_uni}
		
		\medskip
		
		\begin{tabular}{  lr } 
			\toprule
			\makecell{ Feature }  &  Value \\   
			
			\midrule 
			push & 1	\\
			ebx & 3\\
			mov & 2\\
			eax & 6\\
			number & 2\\
			cmp & 2\\
			jle & 2\\
			hex & 3\\
			add & 1\\
			call & 1\\
			ret & 1\\
			apt            & PatchWork          \\ 
			md5            & 1234dc...eb121 \\ 
			\bottomrule
		\end{tabular}
	\end{minipage}\hfill
	\begin{minipage}{.5\linewidth}
		\centering
		
		\caption{Disassemble bigrams}
		\label{tab:dis_big}
		
		\medskip
		
		\begin{tabular}{  lr } 
			\toprule
			\makecell{ Feature }  &  Value \\   
			
			\midrule 
			<s>=>push & 1	\\
			push=>ebx & 1\\
			ebx=>mov & 1\\
			mov=>eax & 2\\
			eax=>num & 2\\
			num=>cmp & 2\\
			cmp=>ebx & 2\\
			ebx=>eax & 2\\
			eax=>jle & 2\\
			jle=>hex & 2\\
			hex=>add & 1\\
			add=>eax & 1\\
			hex=>mov & 1\\
			eax=>hex & 1\\
			hex=>call & 1\\
			call=>hex & 1\\
			hex=>ret & 1\\
			ret=></s> & 1\\
			apt            & PatchWork          \\ 
			md5            & 1234dc...eb121 \\ 
			\bottomrule
		\end{tabular}
	\end{minipage}
\end{table}


\subsection{Instruction only unigrams and bigrams}
For the last block of features, we decided to study only the frequency of the different instructions in the code, without considering the registry. As before in the bigrams, we added a start and an end token to avoid linking two instructions from different functions. The features from the previous example would be:

\begin{table}[!htb]
	\begin{minipage}{.5\linewidth}
		\centering
		
		\caption{Instruction only unigrams}
		\label{tab:instr_uni}
		
		\medskip
		
		\begin{tabular}{  lr } 
			\toprule
			\makecell{ Feature }  &  Value \\   
			
			\midrule 
			push & 1	\\
			mov & 2\\
			cmp & 2\\
			jle & 2\\
			add & 1\\
			call & 1\\
			ret & 1\\
			apt            & PatchWork          \\ 
			md5            & 1234dc...eb121 \\ 
			\bottomrule
		\end{tabular}
	\end{minipage}\hfill
	\begin{minipage}{.5\linewidth}
		\centering
		
		\caption{Instruction only bigrams}
		\label{tab:instr_big}
		
		\medskip
		
		\begin{tabular}{  lr } 
			\toprule
			\makecell{ Feature }  &  Value \\   
			
			\midrule 
			<s>=>push & 1	\\
			push=>mov & 1\\
			mov=>cmp & 1\\
			cmp=>jle & 2\\
			jle=>add & 1\\
			add=>cmp & 1\\
			jle=>mov & 1\\
			mov=>call & 1\\
			call=>ret & 1\\
			ret=></s> & 1\\
			apt            & PatchWork          \\ 
			md5            & 1234dc...eb121 \\ 
			\bottomrule
		\end{tabular}
	\end{minipage}
\end{table}

\section{Control Flow Graph features}

\section{Rich Header features}